" 
" Find and parse compile_commands.json as generated by e.g. cmake -DCMAKE_EXPORT_COMPILE_COMMANDS=ON
" Contains the full command line for compiling any particular file
"

function! getopts#compile_commands#getopts()
	let l:db_path = s:find_db()
	
	" Silently give up if we can't find the file
	if l:db_path == '' || !filereadable(l:db_path)
		return
	endif
	
	exe 'python load_flags("' . l:db_path . '", "' . fnamemodify(expand("%"), ":p") . '")'
endfunction

function! s:find_db()
	" As the compile_commands.json file is likely to be in the build tree, as
	" well as searching for the file itself, also search for possible build
	" directories containg the file
	let l:search_files = ['compile_commands.json', 'build/compile_commands.json', 'cmake_build/compile_commands.json', 'cmake/compile_commands.json']
	if exists("g:clang_compile_commands_try_filenames") " Support adding additional names/build directories to search for
		let l:search_files += g:clang_compile_commands_try_filenames
	endif
	let l:search_dirs = getcwd() . ',.;' " search from current directory (getcwd), and location of file (.)
	
	let l:db_path = ''
	for l:f in l:search_files
		let l:db_path = findfile(l:f, l:search_dirs)
		if l:db_path != ''
			break
		endif
	endfor
	
	return l:db_path
endfunction

" Actual parsing code
" This is in Python simply because of its handy built in libraries
python << EOF
import vim
import json
import shlex
import os.path

def filter_cmd_line(cmd_line, filename):
	# json.load returns unicode strings. libclang, shlex, etc. require byte strings
	# libclang seems to generally expect utf-8
	cmd_line = cmd_line.encode('utf-8');
	args = shlex.split(cmd_line) 
	
	# args is the full command line to compile with, so includes the compiler to call 
	# and the file being compiled
	# Clang gets confused if we pass these as flags, so try and strip them out
	# - assumes the very first argument is the compiler and is dropped unconditionally
	# - assumes any args ending with the name of the current file can be dropped
	# Obviously not ideal, but so far seems to be "good enough"
	args = args[1:]
	args = filter((lambda x: not x.endswith(os.path.basename(filename))), args)
	
	# clang_complete has a single string with command line arguments appended
	# to it, arguments with spaces need quotes
	return " ".join(map(lambda x: " " in x and ('"' + x + '"') or x, args))

def load_flags(db_path, filename):
	db_file = open(db_path, 'r')
	db = json.load(db_file)
	db_file.close
	for f in db:
		if f['file'] == filename:
			vim.command("let b:clang_user_options .= ' " + filter_cmd_line(f['command'], filename) + "'")
			break
EOF

